# SLOTHY: Assembly Optimization via Constraint Solving

## Introduction

### Overview

**SLOTHY** - **S**uper (**L**azy) **O**ptimization of **T**ricky **H**andwritten assembl**Y** - is an *assembly-level superoptimizer*
for solving the following tasks _simultaneously_:
1. Instruction scheduling,
2. Register allocation, and
3. Software pipelining (= periodic loop interleaving)

SLOTHY is generic in the underlying architecture and microarchitecture. This repository provides instantiations for the
the Cortex-M55 and Cortex-M85 CPUs implementing Armv8.1-M + Helium, as well as the Cortex-A55 and Cortex-A72
CPUs implementing Armv8-A + Neon. SLOTHY is discussed in detail in the paper [Fast and Clean: Auditable high-performance assembly via constraint solving](https://eprint.iacr.org/2022/1303). Implementions optimized by SLOTHY have been merged into [pqmx](https://github.com/slothy-optimizer/pqmx) (for Cortex-M) and [pqax](https://github.com/slothy-optimizer/pqax) (for Cortex-A).

The goal of SLOTHY is to enable optimal code for workloads which are too complex for other methods
such as autovectorization or intrinsics to yield high(est) performance results, and for which every last % of
performance counts.

### How it works

SLOTHY is essentially a constraint solver frontend: It converts the input source into a computation flow graph and then
lists variables and constraints defining valid instruction schedulings, register renamings, and (in the case of loops)
periodic loop interleavings. Those variables and constraints are then passed to an external constraint solver and, in
case of success, the satisfying assignment returned from the solver converted back into a piece of code. As it stands,
SLOTHY uses [Google OR-Tools](https://developers.google.com/optimization) as its constraint solver.

For more details, see [Fast and Clean: Auditable high-performance assembly via constraint solving](https://eprint.iacr.org/2022/1303) again.

### Performance

As a rough rule of thumb, SLOTHY typically manages to optimize workloads of <50 instructions in seconds to minutes, workloads
up to 150 instructions in minutes to hours, while for larger kernels some heuristics are necessary.

### NOTE

1. The software optimization information (such as latencies and throughputs of instructions) captured
   in repository are experimental and do _not_ constitute official software optimization guides!
2. SLOTHY can only optimize code with respect to constraints it knows about, such as latencies and throughput. Those
   being approximative as just mentioned, _and_ not a complete model of the microarchitecture, it is not guaranteed that
   code which SLOTHY reports as satisfying all constraints is actually stall-free. You should always
   double-check the actual performance by running the optimized code on real hardware!

## Setup

### Dependencies

SLOTHY relies on [Google OR-Tools](https://developers.google.com/optimization) as the underlying constraint
solver. You need at least v9.3, and we recommend version >=v9.5.2040 because of
[https://github.com/google/or-tools/issues/3483](https://github.com/google/or-tools/issues/3483), but SLOTHY has a
workaround in place otherwise.

Unless you already have a working installation, you can clone Google OR-Tools as a submodule of this repository.

```
> git submodule init
> git submodule update
```

When compiling from scratch, note that you need to build the Python interface by setting `BUILD_PYTHON`. For example, if
you're in the base directory of repository and use OR-Tools as a submodule, do the following:
```
> cd submodules/or-tools
> mkdir build
> cmake -S. -Bbuild -DBUILD_PYTHON:BOOL=ON
> cd build
> make
```

You also need to install `sympy`. To add it to the virtual Python environment provided by OR-Tools, do
```
> source submodules/or-tools/build/python/venv/bin/activate
> pip3 install sympy
> deactivate
```

All of the above commands are run by the shell script [submodules/setup-ortools.sh](submodules/setup-ortools.sh)
provided for convenience.

Once set up, you only need to start the virtual environment

```
> source submodules/or-tools/build/python/venv/bin/activate
```

To reduce the typing burden

```
> source init.sh
```

does this.

### Quick check

To check that your setup is complete, try the following from the base directory:

```
> ./slothy-m55-cli examples/naive/simple1.s
```

This should show something like the following:

```
% ./slothy-m55-cli examples/naive/simple1.s
+ ./slothy-cli Arm_v81M Arm_Cortex_M55 examples/naive/simple1.s
INFO:slothy-cli.slothy:Attempt optimization with max 0 stalls...
INFO:slothy-cli.slothy.input:Statically assign global input r0 to register r0
INFO:slothy-cli.slothy.input:Statically assign global input q1 to register q1
INFO:slothy-cli.slothy.input:Statically assign global input r1 to register r1
INFO:slothy-cli.slothy:No objective -- any satisfying solution is fine
INFO:slothy-cli.slothy:Writing model to slothy-cli_slothy_0_stalls.txt...
INFO:slothy-cli.slothy:Invoking external constraint solver...
INFO:slothy-cli.slothy:Attempt optimization with max 1 stalls...
INFO:slothy-cli.slothy.input:Statically assign global input r0 to register r0
INFO:slothy-cli.slothy.input:Statically assign global input q1 to register q1
INFO:slothy-cli.slothy.input:Statically assign global input r1 to register r1
INFO:slothy-cli.slothy:No objective -- any satisfying solution is fine
INFO:slothy-cli.slothy:Writing model to slothy-cli_slothy_1_stalls.txt...
INFO:slothy-cli.slothy:Invoking external constraint solver...
INFO:slothy-cli.slothy:Found 1 solutions so far... objective value = 0.0 (no objective)
INFO:slothy-cli.slothy:Input const renamed to r12
INFO:slothy-cli.slothy:OPTIMAL, wall time: 0.004099
INFO:slothy-cli.slothy.selfcheck:OK!
        vldrw.u32 q0, [r0]           // *...
        vmla.s32 q0, q1, r12         // .*..
        // gap                       // ....
        vmla.s32 q0, q1, r12         // ..*.
        vstrw.u32 q0, [r1]           // ...*

        // original source code
        // vldrw.u32 q0, [r0]          // *...
        // vmla.s32 q0, q1, const      // .*..
        // vmla.s32 q0, q1, const      // ..*.
        // vstrw.u32 q0, [r1]          // ...*
```

## Basic usage

### Command line interface

The quickest way to experiment with `slothy` is via its command line interface `slothy-cli`:

```
% slothy-cli ARCH TARGET INPUT [options]
```

For example, the above `slothy-m55-cli examples/naive/simple1.s` is merely an abbreviation for `slothy-cli Arm_v81M
Arm_Cortex_M55 examples/naive/simple1.s`.

The most important command line options are the following:

* Configuration of `slothy`: You can set various configuration options via `-c option=value`. For example, to enable
  software pipelining, use `-c sw_pipelining.enabled=True`, or just `-c sw_pipelining.enabled` (generally, `-c option`
  is a shortcut for `-c option=True`, while `-c /option` is a shortcut for `-c option=False`). The hierarchy of
  configuration options is the same as for `Slothy.Config` in [slothy/config.py](slothy/config.py).

* Defining the part of the source code to operate on: Rather than asking `slothy` to optimize an entire file, one will
  usually want to direct it to the optimization of some selected parts of assembly -- for example, the core loop. This
  can be done via the `-start/end {label}` options, which expect assembly labels delimiting the code to be
  optimized. Alternatively, `-loop {label}` can be used to operate on the body of a loop starting at the given label.

* An output file can be specified with `-o`.

You may find SLOTHY complaining about ambiguity of register types if you use symbolic registers rather names sthan
architectural ones. In this case, you need to set `-c config.typing_hints={name1:regtype1,name2:regtype2,...}`. For
example, if the symbolic register name `foo` should be a general purpose register, add `-c config.typing_hints={foo:GPR}`.

For more details, see `slothy-cli --help` and/or the Python documentation.

### Python interface

`slothy` can also be called from Python, as demonstrated in the source code for [slothy-cli](slothy-cli) or the numerous
examples in [example.py](example.py). The basic flow is as follows:

1. Setup a `slothy` instance, passing the architecture and target microarchitecture modules as arguments.
   You can specify architecture modules directly, e.g. `slothy_m55 = Slothy(targets.arm_v81m.arch_v81m,
   targets.arm_v81m.cortex_m55r1)`, or query them from `targets.query` as done in [slothy-cli](slothy-cli).
2. Load the source code to optimize via `load_source_from_file()`
3. Modify the default configuration as desired
4. Call `slothy.optimize(first=START_LABEL, end=END_LABEL)` to optimize and replace the part of the current source code
   between the given labels. Alternatively, call `slothy.optimize_loop(loop_lbl=LABEL)` to do the same for a loop
   starting at label `LABEL` (the end will be detected automatically).
5. If you have multiple sections to be optimized, repeat 3 and 4 above.
6. Print and/or save the final source code via `slothy.print_code()` or `slothy.write_source_to_file()`.

If you want to optimize the intermediate code between two loops which have been optimized via software pipelining,
you'll need to know the dependencies carried across the optimized iterations. After a call to `slothy.optimize_loop()`,
you can query those as `slothy.last_result.kernel_input_output`.

## Basic examples

The [examples](examples/naive) directory contains numerous exemplary assembly snippets. To try them, either use
`python3 example.py --examples={YOUR_EXAMPLE}`. See `python3 examples.py --help` for the list of
all available examples.

Here are some basic examples.

### Optimization of a simple assembly snippet

```
% ./slothy-m55-cli examples/naive/simple0.s
+ ./slothy-cli Arm_v81M Arm_Cortex_M55 examples/naive/simple0.s
INFO:slothy-cli:Instructions in body: 16
INFO:slothy-cli.slothy:Perform binary search for minimal number of stalls...
INFO:slothy-cli.slothy:Attempt optimization with max 0 stalls...
INFO:slothy-cli.slothy:Objective: None (any satisfying solution is fine)
INFO:slothy-cli.slothy:Invoking external constraint solver (OR-Tools CP-SAT v9.7.2996) ...
INFO:slothy-cli.slothy:INFEASIBLE, wall time: 0.0050s
INFO:slothy-cli.slothy:Attempt optimization with max 1 stalls...
INFO:slothy-cli.slothy:Objective: None (any satisfying solution is fine)
INFO:slothy-cli.slothy:Invoking external constraint solver (OR-Tools CP-SAT v9.7.2996) ...
INFO:slothy-cli.slothy:[0.0391s]: Found 1 solutions so far... objective 0.0, bound 0.0 (no objective)
INFO:slothy-cli.slothy:[0.0394s]: Found 2 solutions so far... objective 0.0, bound 0.0 (no objective)
INFO:slothy-cli.slothy:OPTIMAL, wall time: 0.0434s
INFO:slothy-cli.slothy:Booleans in result: 176
INFO:slothy-cli.slothy.selfcheck:OK!
        vldrw.u32 q7, [r5]                // *...............
        // gap                            // ................
        vldrw.u32 q0, [r1] , #16          // ...*............
        vmulh.u32 q1, q7, q0              // ....*...........
        vldrw.u32 q7, [r5, #32]           // ..*.............
        vadd.u32 q5, q1, q1               // .......*........
        vmulh.u32 q7, q7, q0              // ......*.........
        vadd.u32 q6, q5, q0               // ........*.......
        vldrw.u32 q2, [r5, #16]           // .*..............
        vadd.u32 q4, q7, q7               // ...........*....
        vmulh.u32 q5, q2, q0              // .....*..........
        vadd.u32 q1, q4, q0               // ............*...
        vstrw.u32 q1, [r5, #32]           // ..............*.
        vadd.u32 q3, q5, q5               // .........*......
        vstrw.u32 q6, [r5] , #48          // ...............*
        vadd.u32 q6, q3, q0               // ..........*.....
        vstrw.u32 q6, [r5, #-32]          // .............*..

        // original source code
        // vldrw.u32  q0, [inA]           // *...............
        // vldrw.u32  q1, [inA, #16]      // .......*........
        // vldrw.u32  q2, [inA, #32]      // ...*............
        // vldrw.u32  q7, [inB], #16      // .*..............
        // vmulh.u32  q0, q0, q7          // ..*.............
        // vmulh.u32  q1, q1, q7          // .........*......
        // vmulh.u32  q2, q2, q7          // .....*..........
        // vadd.u32   q0, q0, q0          // ....*...........
        // vadd.u32   q0, q0, q7          // ......*.........
        // vadd.u32   q1, q1, q1          // ............*...
        // vadd.u32   q1, q1, q7          // ..............*.
        // vadd.u32   q2, q2, q2          // ........*.......
        // vadd.u32   q2, q2, q7          // ..........*.....
        // vstrw.u32  q1, [inA, #16]      // ...............*
        // vstrw.u32  q2, [inA, #32]      // ...........*....
        // vstrw.u32  q0, [inA], #48      // .............*..
```

To write the output to a file, use

```
> ./slothy-m55-cli examples/naive/simple0.s --output examples/opt/simple0.s
```

### Optimization of a simple snippet, software pipelining ("loop mode")

```
./slothy-m55-cli examples/naive/simple0.s -c sw_pipelining.enabled=True -c variable_size -c sw_pipelining.optimize_preamble=False -c sw_pipelining.optimize_postamble=False
+ ./slothy-cli Arm_v81M Arm_Cortex_M55 examples/naive/simple0.s -c sw_pipelining.enabled=True -c variable_size -c sw_pipelining.optimize_preamble=False -c sw_pipelining.optimize_postamble=False
INFO:slothy-cli:- Setting configuration option enabled to value True
INFO:slothy-cli:- Setting configuration option variable_size to value True
INFO:slothy-cli:- Setting configuration option optimize_preamble to value False
INFO:slothy-cli:- Setting configuration option optimize_postamble to value False
INFO:slothy-cli:Instructions in body: 16
WARNING:slothy-cli:You are using SW pipelining without setting inputs_are_outputs=True. This means that the last iteration of the loop may overwrite inputs to the loop (such as address registers), unless they are marked as reserved registers. If this is intended, ignore this warning. Otherwise, consider setting inputs_are_outputs=True to ensure that nothing that is used as an input to the loop is overwritten, not even in the last iteration.
INFO:slothy-cli.slothy:Perform binary search for minimal number of stalls...
INFO:slothy-cli.slothy:Attempt optimization with max 0 stalls...
INFO:slothy-cli.slothy:Objective: minimize number of stalls
INFO:slothy-cli.slothy:Invoking external constraint solver (OR-Tools CP-SAT v9.7.2996) ...
INFO:slothy-cli.slothy:[0.3011s]: Found 1 solutions so far... objective 0.0, bound 0.0 (minimize number of stalls)
INFO:slothy-cli.slothy:Closer than 0 stalls to theoretical optimum... stop
INFO:slothy-cli.slothy:OPTIMAL, wall time: 0.3070s
INFO:slothy-cli.slothy:Booleans in result: 1140
INFO:slothy-cli.slothy:Number of early instructions: 11
INFO:slothy-cli.slothy.selfcheck:OK!
INFO:slothy-cli.slothy:Minimum number of stalls: 0
INFO:slothy-cli.slothy:Optimize again with minimal number of 0 stalls, with objective...
INFO:slothy-cli.slothy:Objective: minimize iteration overlapping
INFO:slothy-cli.slothy:Invoking external constraint solver...
INFO:slothy-cli.slothy:[0.2939s]: Found 1 solutions so far... objective 11.0, bound 1.0 (minimize iteration overlapping)
INFO:slothy-cli.slothy:[0.3029s]: Found 2 solutions so far... objective 10.0, bound 1.0 (minimize iteration overlapping)
INFO:slothy-cli.slothy:[0.3141s]: Found 3 solutions so far... objective 9.0, bound 1.0 (minimize iteration overlapping)
INFO:slothy-cli.slothy:[0.3301s]: Found 4 solutions so far... objective 8.0, bound 1.0 (minimize iteration overlapping)
INFO:slothy-cli.slothy:[0.3332s]: Found 5 solutions so far... objective 7.0, bound 1.0 (minimize iteration overlapping)
INFO:slothy-cli.slothy:[0.3416s]: Found 6 solutions so far... objective 5.0, bound 2.0 (minimize iteration overlapping)
INFO:slothy-cli.slothy:OPTIMAL, wall time: 0.3893s
INFO:slothy-cli.slothy:Number of early instructions: 5
INFO:slothy-cli.slothy.selfcheck:OK!

        ... omitting preamble ...

        // Kernel
        vmulh.u32 q7, q4, q5             // ....*...........
        vadd.u32 q1, q6, q5              // ............*...
        vldrw.u32 q4, [r3, #16]          // .*..............
        vadd.u32 q7, q7, q7              // .......*........
        vstrw.u32 q1, [r3, #32]          // ..............*.
        vadd.u32 q3, q7, q5              // ........*.......
        vmulh.u32 q6, q4, q5             // .....*..........
        vldrw.u32 q4, [r3, #48]          // e...............
        vadd.u32 q7, q6, q6              // .........*......
        vldrw.u32 q0, [r3, #80]          // ..e.............
        vadd.u32 q2, q7, q5              // ..........*.....
        vldrw.u32 q5, [r6] , #16         // ...e............
        vmulh.u32 q0, q0, q5             // ......e.........
        vstrw.u32 q2, [r3, #16]          // .............*..
        vadd.u32 q6, q0, q0              // ...........e....
        vstrw.u32 q3, [r3] , #48         // ...............*

        // original source code
        // vldrw.u32  q0, [inA]           // e........................
        // vldrw.u32  q1, [inA, #16]      // ...........*.............
        // vldrw.u32  q2, [inA, #32]      // ..e......................
        // vldrw.u32  q7, [inB], #16      // ....e....................
        // vmulh.u32  q0, q0, q7          // .........*...............
        // vmulh.u32  q1, q1, q7          // ...............*.........
        // vmulh.u32  q2, q2, q7          // .....e...................
        // vadd.u32   q0, q0, q0          // ............*............
        // vadd.u32   q0, q0, q7          // ..............*..........
        // vadd.u32   q1, q1, q1          // .................*.......
        // vadd.u32   q1, q1, q7          // ...................*.....
        // vadd.u32   q2, q2, q2          // .......e.................
        // vadd.u32   q2, q2, q7          // ..........*..............
        // vstrw.u32  q1, [inA, #16]      // ......................*..
        // vstrw.u32  q2, [inA, #32]      // .............*...........
        // vstrw.u32  q0, [inA], #48      // ........................*

        ... omitting postamble ...
```

Here, `e` indicates that the instruction is an early instruction for the next iteration.

### Complex loop, with unrolling

```
./slothy-m55-cli examples/naive/crt.s -c typing_hints="{mod_p_tw:GPR,const_prshift:GPR,p_inv_mod_q_tw:GPR,p_inv_mod_q:GPR,const_shift9:GPR}"
```

The typing hints are necessary here for SLOTHY to disambiguate between
scalar/vector and vector/vector variants of some instructions. The above then tries to optimize a loop implementing the
interpolation step in the Chinese Remainder Theorem (CRT). The loop is very hard to optimize due to a large number of
multiplications and a large number of add/sub/logical operations in the end, and one cannot do better than 4 stalls as witnessed by the output:

```
% ./slothy-m55-cli examples/naive/crt.s \
    -c sw_pipelining.enabled=True       \
    -c typing_hints="{mod_p_tw:GPR,const_prshift:GPR,p_inv_mod_q_tw:GPR,p_inv_mod_q:GPR,const_shift9:GPR}" \
    -c sw_pipelining.optimize_preamble=False  \
    -c sw_pipelining.optimize_postamble=False

+ ./slothy-cli Arm_v81M Arm_Cortex_M55 examples/naive/crt.s -c sw_pipelining.enabled=True -c 'typing_hints={mod_p_tw:GPR,const_prshift:GPR,p_inv_mod_q_tw:GPR,p_inv_mod_q:GPR,const_shift9:GPR}' -c sw_pipelining.optimize_preamble=False -c sw_pipelining.optimize_postamble=False
INFO:slothy-cli:- Setting configuration option enabled to value True
INFO:slothy-cli:- Setting configuration option typing_hints to value {'mod_p_tw': GPR, 'const_prshift': GPR, 'p_inv_mod_q_tw': GPR, 'p_inv_mod_q': GPR, 'const_shift9': GPR}
INFO:slothy-cli:- Setting configuration option optimize_preamble to value False
INFO:slothy-cli:- Setting configuration option optimize_postamble to value False
INFO:slothy-cli:- Setting configuration option unroll to value 1
INFO:slothy-cli:- Setting configuration option variable_size to value True
INFO:slothy-cli:Instructions in body: 23
WARNING:slothy-cli:You are using SW pipelining without setting inputs_are_outputs=True. This means that the last iteration of the loop may overwrite inputs to the loop (such as address registers), unless they are marked as reserved registers. If this is intended, ignore this warning. Otherwise, consider setting inputs_are_outputs=True to ensure that nothing that is used as an input to the loop is overwritten, not even in the last iteration.
INFO:slothy-cli.slothy:Perform binary search for minimal number of stalls...
INFO:slothy-cli.slothy:Attempt optimization with max 0 stalls...
INFO:slothy-cli.slothy:Objective: minimize number of stalls
INFO:slothy-cli.slothy:Invoking external constraint solver (OR-Tools CP-SAT v9.7.2996) ...
INFO:slothy-cli.slothy:INFEASIBLE, wall time: 0.0589s
INFO:slothy-cli.slothy:Attempt optimization with max 1 stalls...
INFO:slothy-cli.slothy:Objective: minimize number of stalls
INFO:slothy-cli.slothy:Invoking external constraint solver (OR-Tools CP-SAT v9.7.2996) ...
INFO:slothy-cli.slothy:INFEASIBLE, wall time: 0.2354s
INFO:slothy-cli.slothy:Attempt optimization with max 2 stalls...
INFO:slothy-cli.slothy:Objective: minimize number of stalls
INFO:slothy-cli.slothy:Invoking external constraint solver (OR-Tools CP-SAT v9.7.2996) ...
INFO:slothy-cli.slothy:INFEASIBLE, wall time: 0.3708s
INFO:slothy-cli.slothy:Attempt optimization with max 4 stalls...
INFO:slothy-cli.slothy:Objective: minimize number of stalls
INFO:slothy-cli.slothy:Invoking external constraint solver (OR-Tools CP-SAT v9.7.2996) ...
INFO:slothy-cli.slothy:[1.1020s]: Found 1 solutions so far... objective 4.0, bound 0.0 (minimize number of stalls)
INFO:slothy-cli.slothy:OPTIMAL, wall time: 1.1695s
INFO:slothy-cli.slothy:Booleans in result: 1237
INFO:slothy-cli.slothy:Number of early instructions: 15
INFO:slothy-cli.slothy.selfcheck:OK!
INFO:slothy-cli.slothy:Minimum number of stalls: 4
INFO:slothy-cli.slothy:Optimize again with minimal number of 4 stalls, with objective...
INFO:slothy-cli.slothy:Objective: minimize iteration overlapping
INFO:slothy-cli.slothy:Invoking external constraint solver...
INFO:slothy-cli.slothy:[0.8246s]: Found 1 solutions so far... objective 15.0, bound 7.0 (minimize iteration overlapping)
INFO:slothy-cli.slothy:OPTIMAL, wall time: 0.9318s
INFO:slothy-cli.slothy:Number of early instructions: 15
INFO:slothy-cli.slothy.selfcheck:OK!
        // Exceptional iterations: 1
        // Preamble
        vldrw.u32 q0, [r3]
        vqdmulh.s32 q6, q0, r4
        vqrdmulh.s32 q5, q6, r8
        vmla.s32 q0, q5, r10
        vldrw.u32 q5, [r5]
        vsub.u32 q6, q5, q0
        vqdmulh.s32 q5, q6, r6
        vrshr.s32 q4, q5, #(SHIFT)
        vmul.u32 q5, q6, r9
        vmla.s32 q5, q4, r7
        vmul.u32 q3, q5, r10
        vqdmulh.s32 q5, q5, r10
        vshr.u32 q4, q3, #22
        vmul.u32 q5, q5, r12
        vorr.u32 q5, q4, q5
        // Kernel
        vshlc q5, r2, #32                  // ................*......
        // gap                             // .......................
        vadd.u32 q7, q0, q5                // .................*.....
        vldrw.u32 q0, [r3]                 // e......................
        vqdmulh.s32 q6, q0, r4             // .e.....................
        // gap                             // .......................
        vqrdmulh.s32 q5, q6, r8            // ..e....................
        // gap                             // .......................
        vmla.s32 q0, q5, r10               // ...e...................
        vldrw.u32 q5, [r5]                 // ....e..................
        vsub.u32 q6, q5, q0                // .....e.................
        vqdmulh.s32 q5, q6, r6             // ......e................
        // gap                             // .......................
        vrshr.s32 q4, q5, #(SHIFT)         // ........e..............
        vmul.u32 q5, q6, r9                // .......e...............
        vand.u32 q6, q3, q1                // ..............*........
        vmla.s32 q5, q4, r7                // .........e.............
        vadd.u32 q6, q6, q7                // ..................*....
        vmul.u32 q3, q5, r10               // ..........e............
        vand.u32 q7, q6, q1                // ...................*...
        vqdmulh.s32 q5, q5, r10            // ...........e...........
        vshr.u32 q4, q3, #22               // ............e..........
        vmul.u32 q5, q5, r12               // .............e.........
        vshlc q6, r11, #32                 // ....................*..
        vqdmlah.s32 q7, q6, r1             // .....................*.
        vorr.u32 q5, q4, q5                // ...............e.......
        vstrw.u32 q7, [r0]                 // ......................*

        // original source code
        // vldrw.u32   in0, [src0]                        // e...........................................
        // vqdmulh.s32 diff, in0, mod_p_tw                // .e..........................................
        // vqrdmulh.s32 tmp, diff, const_prshift          // ..e.........................................
        // vmla.s32    in0, tmp, mod_p                    // ...e........................................
        // vldrw.u32   in1, [src1]                        // ....e.......................................
        // vsub.u32    diff, in1, in0                     // .....e......................................
        // vqdmulh.s32 tmp, diff, p_inv_mod_q_tw          // ......e.....................................
        // vmul.u32    diff, diff, p_inv_mod_q            // ........e...................................
        // vrshr.s32   tmp, tmp, #(SHIFT)                 // .......e....................................
        // vmla.s32    diff, tmp, mod_q_neg               // ..........e.................................
        // vmul.u32    quot_low,  diff, mod_p             // ............e...............................
        // vqdmulh.s32 tmp, diff, mod_p                   // ..............e.............................
        // vshr.u32    tmpp, quot_low,  #22               // ...............e............................
        // vmul.u32    tmp, tmp, const_shift9             // ................e...........................
        // vand.u32    quot_low,  quot_low, qmask         // ................................*...........
        // vorr.u32    tmpp, tmpp, tmp                    // ...................e........................
        // vshlc       tmpp, rcarry, #32                  // .....................*......................
        // vadd.u32    in0, in0, tmpp                     // ......................*.....................
        // vadd.u32    tmpp, quot_low, in0                // ..................................*.........
        // vand.u32 red_tmp, tmpp, qmask                  // ....................................*.......
        // vshlc tmpp, rcarry_red, #32                    // ........................................*...
        // vqdmlah.s32 red_tmp, tmpp, const_rshift22      // .........................................*..
        // vstrw.u32   red_tmp, [dst]                     // ...........................................*
```

However, allowing SLOTHY to double the loop body via `-c sw_pipelining.unroll=2` makes it possible to find a perfect solution
which overlaps the add/sub/logical-heavy part of one iteration with the mul-heavy part of the next:

```
% ./slothy-m55-cli examples/naive/crt.s -c sw_pipelining.enabled=True \
     -c typing_hints="{mod_p_tw:GPR,const_prshift:GPR,p_inv_mod_q_tw:GPR,p_inv_mod_q:GPR,const_shift9:GPR}" \
     -c sw_pipelining.unroll=2 \
     -c sw_pipelining.optimize_preamble=False \
     -c sw_pipelining.optimize_postamble=False
+ ./slothy-cli Arm_v81M Arm_Cortex_M55 examples/naive/crt.s -c sw_pipelining.enabled=True -c 'typing_hints={mod_p_tw:GPR,const_prshift:GPR,p_inv_mod_q_tw:GPR,p_inv_mod_q:GPR,const_shift9:GPR}' -c sw_pipelining.unroll=2 -c sw_pipelining.optimize_preamble=False -c sw_pipelining.optimize_postamble=False
INFO:slothy-cli:- Setting configuration option enabled to value True
INFO:slothy-cli:- Setting configuration option typing_hints to value {'mod_p_tw': GPR, 'const_prshift': GPR, 'p_inv_mod_q_tw': GPR, 'p_inv_mod_q': GPR, 'const_shift9': GPR}
INFO:slothy-cli:- Setting configuration option unroll to value 2
INFO:slothy-cli:- Setting configuration option optimize_preamble to value False
INFO:slothy-cli:- Setting configuration option optimize_postamble to value False
INFO:slothy-cli:Instructions in body: 23
WARNING:slothy-cli:You are using SW pipelining without setting inputs_are_outputs=True. This means that the last iteration of the loop may overwrite inputs to the loop (such as address registers), unless they are marked as reserved registers. If this is intended, ignore this warning. Otherwise, consider setting inputs_are_outputs=True to ensure that nothing that is used as an input to the loop is overwritten, not even in the last iteration.
INFO:slothy-cli.slothy:Perform binary search for minimal number of stalls...
INFO:slothy-cli.slothy:Attempt optimization with max 0 stalls...
INFO:slothy-cli.slothy:Objective: None (any satisfying solution is fine)
INFO:slothy-cli.slothy:Invoking external constraint solver (OR-Tools CP-SAT v9.7.2996) ...
INFO:slothy-cli.slothy:[7.0658s]: Found 1 solutions so far... objective 0.0, bound 0.0 (no objective)
INFO:slothy-cli.slothy:OPTIMAL, wall time: 7.0884s
INFO:slothy-cli.slothy:Booleans in result: 6147
INFO:slothy-cli.slothy:Number of early instructions: 22
INFO:slothy-cli.slothy.selfcheck:OK!
INFO:slothy-cli.slothy:Optimize again with minimal number of 0 stalls, with objective...
INFO:slothy-cli.slothy:Objective: minimize iteration overlapping
INFO:slothy-cli.slothy:Invoking external constraint solver...
INFO:slothy-cli.slothy:[6.2090s]: Found 1 solutions so far... objective 22.0, bound 1.0 (minimize iteration overlapping)
INFO:slothy-cli.slothy:[6.3823s]: Found 2 solutions so far... objective 21.0, bound 3.0 (minimize iteration overlapping)
INFO:slothy-cli.slothy:[6.7158s]: Found 3 solutions so far... objective 20.0, bound 3.0 (minimize iteration overlapping)
INFO:slothy-cli.slothy:[7.1586s]: Found 4 solutions so far... objective 19.0, bound 4.0 (minimize iteration overlapping)
INFO:slothy-cli.slothy:[7.5044s]: Found 5 solutions so far... objective 14.0, bound 4.0 (minimize iteration overlapping)
INFO:slothy-cli.slothy:[8.8792s]: Found 6 solutions so far... objective 13.0, bound 6.0 (minimize iteration overlapping)
INFO:slothy-cli.slothy:[9.8768s]: Found 7 solutions so far... objective 12.0, bound 6.0 (minimize iteration overlapping)
INFO:slothy-cli.slothy:[10.3389s]: Found 8 solutions so far... objective 11.0, bound 6.0 (minimize iteration overlapping)
INFO:slothy-cli.slothy:OPTIMAL, wall time: 11.9505s
INFO:slothy-cli.slothy:Number of early instructions: 11
INFO:slothy-cli.slothy.selfcheck:OK!

        // Kernel
        vqdmulh.s32 q6, q4, r4             // ...........*..................................
        vshr.u32 q4, q0, #22               // ............*.................................
        vmul.u32 q6, q6, r11               // .............*................................
        vldrw.u32 q5, [r0]                 // .......................*......................
        vqdmulh.s32 q2, q5, r5             // ........................*.....................
        vorr.u32 q1, q4, q6                // ...............*..............................
        vqrdmulh.s32 q2, q2, r12           // .........................*....................
        vshlc q1, r1, #32                  // ................*.............................
        vmla.s32 q5, q2, r4                // ..........................*...................
        vldrw.u32 q2, [r7]                 // ...........................*..................
        vsub.u32 q6, q2, q5                // ............................*.................
        vqdmulh.s32 q4, q6, r10            // .............................*................
        vadd.u32 q1, q7, q1                // .................*............................
        vmul.u32 q2, q6, r3                // ..............................*...............
        vrshr.s32 q4, q4, #(SHIFT)         // ...............................*..............
        vldrw.u32 q7, [r0]                 // e.............................................
        vmla.s32 q2, q4, r8                // ................................*.............
        vand.u32 q4, q0, q3                // ..............*...............................
        vqdmulh.s32 q6, q2, r4             // ..................................*...........
        vadd.u32 q4, q4, q1                // ..................*...........................
        vmul.u32 q6, q6, r11               // ....................................*.........
        vand.u32 q0, q4, q3                // ...................*..........................
        vmul.u32 q2, q2, r4                // .................................*............
        vshlc q4, r2, #32                  // ....................*.........................
        vqdmlah.s32 q0, q4, r6             // .....................*........................
        vshr.u32 q1, q2, #22               // ...................................*..........
        vqdmulh.s32 q4, q7, r5             // .e............................................
        vorr.u32 q6, q1, q6                // ......................................*.......
        vqrdmulh.s32 q1, q4, r12           // ..e...........................................
        vshlc q6, r1, #32                  // .......................................*......
        vmla.s32 q7, q1, r4                // ...e..........................................
        vand.u32 q2, q2, q3                // .....................................*........
        vldrw.u32 q4, [r7]                 // ....e.........................................
        vsub.u32 q4, q4, q7                // .....e........................................
        vqdmulh.s32 q1, q4, r10            // ......e.......................................
        vadd.u32 q6, q5, q6                // ........................................*.....
        vmul.u32 q4, q4, r3                // .......e......................................
        vrshr.s32 q1, q1, #(SHIFT)         // ........e.....................................
        vstrw.u32 q0, [r9]                 // ......................*.......................
        vadd.u32 q2, q2, q6                // .........................................*....
        vmla.s32 q4, q1, r8                // .........e....................................
        vand.u32 q1, q2, q3                // ..........................................*...
        vmul.u32 q0, q4, r4                // ..........e...................................
        vshlc q2, r2, #32                  // ...........................................*..
        vqdmlah.s32 q1, q2, r6             // ............................................*.
        vstrw.u32 q1, [r9]                 // .............................................*

        // original source code
        // vldrw.u32   in0, [src0]                        // e............................................................................
        // vqdmulh.s32 diff, in0, mod_p_tw                // ...........e.................................................................
        // vqrdmulh.s32 tmp, diff, const_prshift          // .............e...............................................................
        // vmla.s32    in0, tmp, mod_p                    // ...............e.............................................................
        // vldrw.u32   in1, [src1]                        // .................e...........................................................
        // vsub.u32    diff, in1, in0                     // ..................e..........................................................
        // vqdmulh.s32 tmp, diff, p_inv_mod_q_tw          // ...................e.........................................................
        // vmul.u32    diff, diff, p_inv_mod_q            // .....................e.......................................................
        // vrshr.s32   tmp, tmp, #(SHIFT)                 // ......................e......................................................
        // vmla.s32    diff, tmp, mod_q_neg               // .........................e...................................................
        // vmul.u32    quot_low,  diff, mod_p             // ...........................e.................................................
        // vqdmulh.s32 tmp, diff, mod_p                   // ...............................*.............................................
        // vshr.u32    tmpp, quot_low,  #22               // ................................*............................................
        // vmul.u32    tmp, tmp, const_shift9             // .................................*...........................................
        // vand.u32    quot_low,  quot_low, qmask         // ................................................*............................
        // vorr.u32    tmpp, tmpp, tmp                    // ....................................*........................................
        // vshlc       tmpp, rcarry, #32                  // ......................................*......................................
        // vadd.u32    in0, in0, tmpp                     // ...........................................*.................................
        // vadd.u32    tmpp, quot_low, in0                // ..................................................*..........................
        // vand.u32 red_tmp, tmpp, qmask                  // ....................................................*........................
        // vshlc tmpp, rcarry_red, #32                    // ......................................................*......................
        // vqdmlah.s32 red_tmp, tmpp, const_rshift22      // .......................................................*.....................
        // vstrw.u32   red_tmp, [dst]                     // .....................................................................*.......
        // vldrw.u32   in0, [src0]                        // ..................................*..........................................
        // vqdmulh.s32 diff, in0, mod_p_tw                // ...................................*.........................................
        // vqrdmulh.s32 tmp, diff, const_prshift          // .....................................*.......................................
        // vmla.s32    in0, tmp, mod_p                    // .......................................*.....................................
        // vldrw.u32   in1, [src1]                        // ........................................*....................................
        // vsub.u32    diff, in1, in0                     // .........................................*...................................
        // vqdmulh.s32 tmp, diff, p_inv_mod_q_tw          // ..........................................*..................................
        // vmul.u32    diff, diff, p_inv_mod_q            // ............................................*................................
        // vrshr.s32   tmp, tmp, #(SHIFT)                 // .............................................*...............................
        // vmla.s32    diff, tmp, mod_q_neg               // ...............................................*.............................
        // vmul.u32    quot_low,  diff, mod_p             // .....................................................*.......................
        // vqdmulh.s32 tmp, diff, mod_p                   // .................................................*...........................
        // vshr.u32    tmpp, quot_low,  #22               // ........................................................*....................
        // vmul.u32    tmp, tmp, const_shift9             // ...................................................*.........................
        // vand.u32    quot_low,  quot_low, qmask         // ..............................................................*..............
        // vorr.u32    tmpp, tmpp, tmp                    // ..........................................................*..................
        // vshlc       tmpp, rcarry, #32                  // ............................................................*................
        // vadd.u32    in0, in0, tmpp                     // ..................................................................*..........
        // vadd.u32    tmpp, quot_low, in0                // ......................................................................*......
        // vand.u32 red_tmp, tmpp, qmask                  // ........................................................................*....
        // vshlc tmpp, rcarry_red, #32                    // ..........................................................................*..
        // vqdmlah.s32 red_tmp, tmpp, const_rshift22      // ...........................................................................*.
        // vstrw.u32   red_tmp, [dst]                     // ............................................................................*
```

* Further examples

Further examples can be found in [example.py](example.py) which illustrate how to instruct SLOTHY from
within Python. The input sources to those examples can be found in [examples/naive](examples/naive), and the optimized
versions are in [examples/opt](examples/opt).

The use of SLOTHY from the command line is illustrated in [scripts/](scripts/) supporting the real-world optimizations
for the NTT, FFT and X25519 discussed in [Fast and Clean: Auditable high-performance assembly via constraint solving](https://eprint.iacr.org/2022/1303).
